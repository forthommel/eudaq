% !TEX root = EUDAQUserManual.tex
\section{Writing a Monitor}\label{sec:MonitorWriting}
eudaq::Monitor provides the the base class and common methods to monitor the data quality online. The internal implementation of eudaq::Monitor is very similar to eudaq::DataCollector. The only difference between them is that eudaq::Monitor accepts only a single connection from an eudaq::DataCollector or eudaq::Producer. (not implemented)\\

\subsection{Monitor Prototype}\label{sec:monitor_hh}

\lstinputlisting[label=ls:monitordef, style=cpp, linerange=BEG*DEC-END*DEC]{../../main/lib/core/include/eudaq/Monitor.hh}

\subsection{Example Code}
Here is an example code of a derived Monitor, named Ex0Monitor. It gets configration paratmeter at configration time and do print out the infomation of the received Events. It might do an Event converting depending on how it is configured.
\lstinputlisting[label=ls:ex0monitorcc, style=cpp]{../../user/example/module/src/Ex0Monitor.cc}
Two virtual methods are implemented in Ex0Monitor, \lstinline[style=cpp]{DoConfigure()} and \lstinline[style=cpp]{DoReceive(eudaq::EventUP ev)}. It registers itself to the correlated \lstinline[style=cpp]{eudaq::factory} by the hash number from the name string \lstinline[style=cpp]{Ex0Monitor}.

\subsection{Graphical User Interface}
Normally, to monitoring the data quality, graphic plots are required. It means that an external graphic library is required. ROOT, Qt
and gnuplot can be the possible graphic library.

\subsubsection{StdEventMonitor}
StdEventMonitor is an EUDAQ version 1 legacy. It was named as OnlineMonitor. Actually, it can only display the plots from StandardEvent. If the Converter to StandardEvent of the incoming Event exists, StdEventMonitor will call the correlated Converter and do the converting itself.
StdEventMonitor depends ROOT to generate and plot graph.

\subsubsection{Generic ROOT monitor}
For projects requiring the online monitoring of a limited amount of specific quantities a ROOT-based visualisation system may be used as a base class.
A limited set of virtual and pure virtual methods are required to define a monitor, as listed below.

\lstinputlisting[label=ls:rootmondef, style=cpp, linerange=BEG*DEC-END*DEC]{../../monitors/rootmonitor/include/eudaq/ROOTMonitor.hh}

The online monitoring analysis code may therefore be implemented inside the derivative object's \lstinline[style=cpp]{AtEventReception(eudaq::EventSP ev)} method, while all histograms booking and registration are performed either within the \lstinline[style=cpp]{AtInitialisation()} or in the \lstinline[style=cpp]{AtConfiguration()} member.

For this latter stage, a templated method is provided to book, both in runtime memory and in the collection of monitoring plots handled by the graphical interface, any \lstinline[style=cpp]{TObject}-derivative ROOT container.
It may be invoked with the help from \lstinline[style=cpp]{eudaq::ROOTMonitor}'s \lstinline[style=cpp]{m_monitor} protected member defining the graphical part of the tool.
For instance, a one-dimensional histogram and a two-dimensional graphics object may be booked through:

\begin{lstlisting}[style=cpp]
TH1D* m_my_hist = m_monitor->Book<TH1D>("path/to/the/monitor", "Sample histogram", "h_my_hist", "My histogram;My variable;Entries", 100, 0., 1.);
TGraph* m_my_graph = m_monitor->Book<TGraph>("path/to/the/graph", "Sample graph");
\end{lstlisting}

In this scheme, the first two \lstinline[style=cpp]{Book} arguments are referring to the absolute path to the object within the monitoring window, and its human-readable name. The following argument(s) (if any) is/are directly fed to the templated object's constructor.
This method returns the memory address to the newly created object (no destruction required, as it will be handled internally), preferably to be used as a derivative monitoring object's private attributes.

Obviously, the only dependency required to build this intermediate object is ROOT.
